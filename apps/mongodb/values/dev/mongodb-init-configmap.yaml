apiVersion: v1
kind: ConfigMap
metadata:
  name: mongodb-init
  namespace: mongodb-dev
data:
  init-replica.js: |
    // Script optimizado para alta disponibilidad en entornos Kubernetes
    // Dise√±ado para mantener la consistencia a pesar de reinicios de pods
    
    print("Verificando el estado actual del cluster MongoDB...");
    
    // Funci√≥n para esperar hasta 30 segundos a que todos los nodos est√©n disponibles
    function waitForAllNodes() {
      var maxWaitTime = 30; // segundos
      var waited = 0;
      var allAvailable = false;
      
      print("Esperando a que todos los miembros del cluster est√©n disponibles...");
      
      while (!allAvailable && waited < maxWaitTime) {
        try {
          var hosts = [
            "mongodb-0.mongodb:27017",
            "mongodb-1.mongodb:27017",
            "mongodb-2.mongodb:27017"
          ];
          
          var allResponding = true;
          hosts.forEach(function(host) {
            try {
              var conn = new Mongo("mongodb://" + host);
              var adminDb = conn.getDB("admin");
              var ping = adminDb.runCommand({ ping: 1 });
              if (ping.ok !== 1) {
                allResponding = false;
                print("‚ö†Ô∏è El nodo " + host + " no responde correctamente");
              } else {
                print("‚úÖ El nodo " + host + " est√° respondiendo");
              }
            } catch (nodeErr) {
              allResponding = false;
              print("‚ö†Ô∏è No se puede conectar a " + host + ": " + nodeErr);
            }
          });
          
          if (allResponding) {
            allAvailable = true;
            print("‚úÖ Todos los nodos est√°n disponibles");
          } else {
            print("‚è≥ Esperando a que todos los nodos est√©n disponibles...");
            sleep(2000);
            waited += 2;
          }
        } catch (e) {
          print("Error al verificar nodos: " + e);
          sleep(2000);
          waited += 2;
        }
      }
      
      return allAvailable;
    }
    
    // Funci√≥n para obtener hostname del nodo actual
    function getHostname() {
      var hostname = "";
      try {
        // Intentar obtener el hostname usando command
        var result = db.runCommand({ hostInfo: 1 });
        if (result.ok === 1) {
          hostname = result.system.hostname;
        }
      } catch (e) {
        print("Error al obtener hostname: " + e);
      }
      return hostname;
    }
    
    // Funci√≥n para determinar si este es el nodo maestro original
    function isPrimaryCandidate() {
      var hostname = getHostname();
      // mongodb-0 siempre se considera el candidato principal
      return hostname.includes("mongodb-0");
    }
    
    // Verificar si el replica set est√° funcionando correctamente
    var isMaster = null;
    var needsConfiguration = false;
    var currentConfig = null;
    
    try {
      isMaster = db.adminCommand({ isMaster: 1 });
      print("Estado de isMaster del nodo: " + JSON.stringify(isMaster));
      
      if (isMaster.setName && isMaster.setName === "rs0") {
        print("‚úÖ Este nodo pertenece al replica set 'rs0'");
        
        try {
          var rsStatus = rs.status();
          if (rsStatus.ok === 1) {
            print("‚úÖ Replica set est√° funcionando correctamente");
            print("Miembros del replica set:");
            rsStatus.members.forEach(function(member) {
              print(" - " + member.name + " (estado: " + member.stateStr + ")");
            });
            
            // Verificar si la configuraci√≥n est√° completa
            try {
              currentConfig = rs.conf();
              
              // Verificar que todos los nodos est√°n en la configuraci√≥n
              var expectedHosts = [
                "mongodb-0.mongodb:27017",
                "mongodb-1.mongodb:27017",
                "mongodb-2.mongodb:27017"
              ];
              
              var configuredHosts = [];
              currentConfig.members.forEach(function(member) {
                configuredHosts.push(member.host);
              });
              
              var missingHosts = expectedHosts.filter(function(host) {
                return configuredHosts.indexOf(host) === -1;
              });
              
              if (missingHosts.length > 0) {
                print("‚ö†Ô∏è Faltan nodos en la configuraci√≥n: " + missingHosts.join(", "));
                needsConfiguration = true;
              } else {
                print("‚úÖ Todos los nodos esperados est√°n en la configuraci√≥n");
                
                // Verificar si hay nodos adicionales inesperados
                var unexpectedHosts = configuredHosts.filter(function(host) {
                  return expectedHosts.indexOf(host) === -1;
                });
                
                if (unexpectedHosts.length > 0) {
                  print("‚ö†Ô∏è Hay nodos inesperados en la configuraci√≥n: " + unexpectedHosts.join(", "));
                  needsConfiguration = true;
                }
              }
            } catch (confErr) {
              print("‚ö†Ô∏è Error al obtener configuraci√≥n: " + confErr);
              needsConfiguration = true;
            }
          } else {
            print("‚ö†Ô∏è Replica set en estado inv√°lido: " + JSON.stringify(rsStatus));
            needsConfiguration = true;
          }
        } catch (statusErr) {
          print("‚ö†Ô∏è Error al verificar estado del replica set: " + statusErr);
          needsConfiguration = true;
        }
      } else {
        print("‚ö†Ô∏è Este nodo no pertenece al replica set 'rs0'");
        needsConfiguration = true;
      }
    } catch (e) {
      print("‚ö†Ô∏è Error al verificar isMaster: " + e);
      needsConfiguration = true;
    }
    
    // Si no necesita configuraci√≥n, simplemente salimos
    if (!needsConfiguration) {
      print("‚úÖ El replica set est√° configurado correctamente");
      quit(0);
    }
    
    // Si necesita configuraci√≥n, s√≥lo el candidato principal (mongodb-0) debe configurarlo
    if (!isPrimaryCandidate()) {
      print("‚è≥ Este nodo no es el candidato principal (mongodb-0)");
      print("‚è≥ Esperando a que el nodo principal configure el replica set...");
      quit(0);
    }
    
    // Aqu√≠ s√≥lo contin√∫a mongodb-0
    print("Este nodo es el candidato principal. Intentando configurar el replica set...");
    
    // Esperar a que todos los nodos est√©n disponibles antes de configurar
    var allNodesAvailable = waitForAllNodes();
    if (!allNodesAvailable) {
      print("‚ö†Ô∏è No todos los nodos est√°n disponibles despu√©s de esperar");
      print("‚ö†Ô∏è Continuando de todos modos, pero es posible que el replica set no se configure correctamente");
    }
    
    // Configurar el replica set
    try {
      print("Iniciando configuraci√≥n del replica set...");
      
      // Si ya hay una configuraci√≥n, intentar actualizarla
      if (currentConfig && currentConfig._id) {
        print("Actualizando configuraci√≥n existente...");
        
        // Crear una nueva configuraci√≥n basada en la actual
        var newMembers = [
          { _id: 0, host: "mongodb-0.mongodb:27017", priority: 2 },
          { _id: 1, host: "mongodb-1.mongodb:27017", priority: 1 },
          { _id: 2, host: "mongodb-2.mongodb:27017", priority: 1 }
        ];
        
        var newConfig = {
          _id: currentConfig._id,
          version: currentConfig.version + 1,
          members: newMembers
        };
        
        // Si hay un problema con la configuraci√≥n, intentar actualizar con fuerza
        try {
          print("Aplicando nueva configuraci√≥n...");
          var reconfigResult = rs.reconfig(newConfig, { force: true });
          print("Resultado de reconfiguraci√≥n: " + JSON.stringify(reconfigResult));
        } catch (reconfigErr) {
          print("Error en reconfiguraci√≥n: " + reconfigErr);
          
          // Intentar con replSetReconfig directamente si rs.reconfig falla
          try {
            print("Intentando con replSetReconfig...");
            var forceResult = db.adminCommand({ replSetReconfig: newConfig, force: true });
            print("Resultado de replSetReconfig: " + JSON.stringify(forceResult));
          } catch (forceErr) {
            print("Error en replSetReconfig: " + forceErr);
            print("No se pudo reconfigurar el replica set");
          }
        }
      } else {
        // Si no hay configuraci√≥n previa, iniciar una nueva
        print("Iniciando una nueva configuraci√≥n del replica set...");
        
        var initConfig = {
          _id: "rs0",
          members: [
            { _id: 0, host: "mongodb-0.mongodb:27017", priority: 2 },
            { _id: 1, host: "mongodb-1.mongodb:27017", priority: 1 },
            { _id: 2, host: "mongodb-2.mongodb:27017", priority: 1 }
          ]
        };
        
        var initResult = rs.initiate(initConfig);
        print("Resultado de inicializaci√≥n: " + JSON.stringify(initResult));
      }
      
      // Esperar a que la configuraci√≥n se aplique
      print("Esperando a que la configuraci√≥n se aplique...");
      sleep(5000);
      
      // Verificar el estado final
      try {
        var finalStatus = rs.status();
        print("Estado final del replica set: " + JSON.stringify(finalStatus));
        
        if (finalStatus.ok === 1) {
          print("‚úÖ Replica set configurado correctamente");
          
          // Imprimir estado de los miembros
          finalStatus.members.forEach(function(member) {
            print(" - " + member.name + ": " + member.stateStr);
          });
          
          quit(0);
        } else {
          print("‚ö†Ô∏è El replica set a√∫n tiene problemas despu√©s de la configuraci√≥n");
        }
      } catch (finalErr) {
        print("Error al verificar estado final: " + finalErr);
      }
    } catch (setupErr) {
      print("Error durante la configuraci√≥n: " + setupErr);
    }
    
    print("Proceso de configuraci√≥n completado. El cluster puede requerir m√°s tiempo para estabilizarse.");
  startup-script.sh: |
    #!/bin/bash
    set -e
    
    echo "Ejecutando script de auto-recuperaci√≥n para MongoDB ReplicaSet..."
    
    # Funci√≥n para detectar si hay archivos corruptos
    check_corruption() {
      local corrupted=0
      
      # Verificar si existen archivos lock que puedan estar causando problemas
      if [ -f /data/db/mongod.lock ]; then
        echo "‚ö†Ô∏è Encontrado archivo de bloqueo mongod.lock - posible cierre incorrecto"
        corrupted=1
      fi
      
      # Verificar si local.0 y local.ns existen pero est√°n en estado inconsistente
      if [ -f /data/db/local.0 ] && [ -f /data/db/local.ns ]; then
        echo "Verificando integridad de archivos de ReplicaSet..."
        
        # Si el tama√±o es 0 o muy peque√±o para archivos cr√≠ticos, podr√≠a indicar corrupci√≥n
        if [ "$(stat -c%s /data/db/local.0)" -lt 1024 ] || [ "$(stat -c%s /data/db/local.ns)" -lt 1024 ]; then
          echo "‚ö†Ô∏è Archivos de base de datos local posiblemente corruptos (tama√±o anormal)"
          corrupted=1
        fi
      fi
      
      # Buscar archivos journal incompletos
      if find /data/db/journal -name "*.incomplete" 2>/dev/null | grep -q .; then
        echo "‚ö†Ô∏è Encontrados archivos journal incompletos"
        corrupted=1
      fi
      
      return $corrupted
    }
    
    # Funci√≥n para limpiar archivos corruptos
    clean_corruption() {
      echo "üßπ Limpiando archivos de configuraci√≥n corruptos del ReplicaSet..."
      
      # Eliminar archivos de configuraci√≥n locales que afectan al replicaset
      rm -f /data/db/mongod.lock /data/db/WiredTiger.lock 2>/dev/null || true
      
      # Si la corrupci√≥n es seria, eliminar archivos de replica set
      # Esto es dr√°stico pero efectivo para casos recurrentes
      hostname=$(hostname)
      if [[ "$hostname" == *"mongodb-0"* ]]; then
        echo "Este es el nodo primario (mongodb-0). Eliminando archivos de ReplicaSet para reinicializaci√≥n limpia..."
        rm -f /data/db/local.0 /data/db/local.ns /data/db/replset* 2>/dev/null || true
      fi
      
      echo "Limpieza completada. MongoDB iniciar√° con configuraci√≥n limpia."
    }
    
    # Comprobar si hay corrupci√≥n y limpiar si es necesario
    if check_corruption; then
      echo "üìõ Detectada posible corrupci√≥n en archivos de MongoDB."
      clean_corruption
    else
      echo "‚úÖ No se detectaron problemas con los archivos de configuraci√≥n."
    fi
    
    echo "Continuando con el inicio normal de MongoDB..."
